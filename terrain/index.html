<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>WebGL FPS - Terrain</title>
<style>
     html,body{margin:0;height:100%;overflow:hidden;background:#000;font-family:sans-serif;}
     canvas{width:100vw;height:100vh;display:block;}

     /* Start menu overlay (unchanged) */
     #menu {
          position: absolute;
          inset: 0;
          background: rgba(0,0,0,0.75);
          display: flex;
          flex-direction: column;
          align-items: center;
          justify-content: center;
          color: white;
          z-index: 10;
     }
     #menu button {
          font-size: 20px;
          padding: 10px 20px;
          margin-top: 20px;
          cursor: pointer;
     }
     #menu label {
          font-size: 18px;
          margin-top: 10px;
          cursor: pointer;
     }
</style>
</head>
<body>

<div id="menu">
     <h1>Start Game</h1>
     <label>
          <input type="checkbox" id="invertBox">
          Invert Camera
     </label>
     <label>
          <input type="range" id="sensitivitySlider" min="0.0001" max="0.01"     step="0.001" value="0.002">
          sensitivity: <label id="sensitivityLabel">0.002</label>
     </label>
     <label for="timeSelect" style="margin-top: 10px; font-size: 18px;">Time of Day:</label>
     <select id="timeSelect" style="font-size: 16px; padding: 5px; margin-top: 5px; border-radius: 5px; background: #333; color: white; border: 1px solid #555;">
          <option value="0">Noon</option>
          <option value="1" selected>Midday</option>
          <option value="2">Sundown</option>
          <option value="3">Night</option>
     </select>
     <button id="startBtn">Start</button>
</div>

<canvas id="c"></canvas>

<script>
// --- HTML Element Setup (unchanged) ---
const canvas=document.getElementById("c");
const menu=document.getElementById("menu");
const startBtn=document.getElementById("startBtn");
const invertBox=document.getElementById("invertBox");
const sensitivitySlider=document.getElementById("sensitivitySlider");
const sensitivityLabel=document.getElementById("sensitivityLabel");
const timeSelect = document.getElementById("timeSelect");

let sensitivity = -0.002;
let invertCamera = false;
let timeOfDay = parseInt(timeSelect.value, 10);
let sunDir = new Float32Array(3);
updateSunPosition(timeOfDay);

startBtn.onclick = () => {
     invertCamera = invertBox.checked;
     menu.style.display = "none";
     canvas.requestPointerLock({unadjustedMovement:true});
};
sensitivitySlider.onchange = () => {
     sensitivity = sensitivitySlider.value;
     sensitivityLabel.innerHTML = sensitivitySlider.value
};
invertBox.onchange = () => {
     invertCamera = invertBox.checked;
     sensitivity = sensitivity * -1
};
timeSelect.onchange = () => {
          timeOfDay = parseInt(timeSelect.value, 10);
          updateSunPosition(timeOfDay);
};
canvas.addEventListener('click', function() {canvas.requestPointerLock({unadjustedMovement:true});}, false);

/* ----------------------- WebGL Setup (unchanged) ----------------------- */
const gl=canvas.getContext("webgl");
if(!gl) alert("WebGL not supported");

function resize(){
     let dpr=window.devicePixelRatio||1;
     canvas.width=canvas.clientWidth*dpr;
     canvas.height=canvas.clientHeight*dpr;
     gl.viewport(0,0,canvas.width,canvas.height);
}
addEventListener("resize",resize);
resize();

/* ---- Shaders ---- */
const vsSrc=`
attribute vec3 a_pos;
attribute vec3 a_nrm; // NEW: Attribute for the vertex normal

uniform mat4 u_mvp;

varying vec3 v_pos;
varying vec3 v_nrm; // NEW: Varying to pass normal to fragment shader

void main(){
     v_pos = a_pos;
     v_nrm = a_nrm;     // NEW: Pass the normal
     gl_Position = u_mvp * vec4(a_pos,1.0);
}`;

// --- MODIFIED Fragment Shader ---
const fsSrc = `
precision highp float;

varying vec3 v_pos;
varying vec3 v_nrm;     // NEW: Received from vertex shader
uniform int u_mode;
uniform int u_timeOfDay;
uniform vec3 u_sunDir;

// (Noise functions hash, noise, fbm are unchanged)
float hash(vec3 p) {
  p = fract(p * vec3(0.1031, 0.1030, 0.0973));
  p += dot(p, p.yzx + 33.33);
  return fract((p.x + p.y) * p.z);
}
float noise(vec3 p) {
  vec3 i = floor(p); vec3 f = fract(p);
  vec3 u = f * f * (3.0 - 2.0 * f);
  float a = hash(i + vec3(0.0, 0.0, 0.0));
  float b = hash(i + vec3(1.0, 0.0, 0.0));
  float c = hash(i + vec3(0.0, 1.0, 0.0));
  float d = hash(i + vec3(1.0, 1.0, 0.0));
  float e = hash(i + vec3(0.0, 0.0, 1.0));
  float f_ = hash(i + vec3(1.0, 0.0, 1.0));
  float g = hash(i + vec3(0.0, 1.0, 1.0));
  float h = hash(i + vec3(1.0, 1.0, 1.0));
  return mix(mix(mix(a, b, u.x), mix(c, d, u.x), u.y),
       mix(mix(e, f_, u.x), mix(g, h, u.x), u.y), u.z);
}
float fbm(vec3 p) {
  float total = 0.0; float amplitude = 0.5; float frequency = 1.0;
  for(int i = 0; i < 4; i++) {
    total += amplitude * noise(p * frequency);
    frequency *= 2.0; amplitude *= 0.5;
  }
  return total;
}

void main() {

 if (u_mode == 1) {
  // --- SKYBOX MODE (Unchanged) ---
  vec3 dir = normalize(v_pos);
  vec3 moonDir = normalize(-u_sunDir);
  float sunDot = dot(dir, u_sunDir);
  float moonDot = dot(dir, moonDir);
  float skyMix;
  if (u_timeOfDay == 0) {
    skyMix = smoothstep(-0.2, 0.7, sunDot);
  } else if (u_timeOfDay == 2) {
    skyMix = smoothstep(-0.1, 0.5, sunDot);
  } else {
    skyMix = max(dir.y, 0.0);
  }
  vec3 colorA, colorB, cloudColor;
  if (u_timeOfDay == 0) {
    colorA = vec3(0.8, 0.9, 1.0);
    colorB = vec3(0.3, 0.5, 0.8);
    cloudColor = vec3(1.0, 1.0, 1.0);
  } else if (u_timeOfDay == 1) {
    colorA = vec3(0.6, 0.8, 1.0);
    colorB = vec3(0.3, 0.5, 0.8);
    cloudColor = vec3(1.0, 1.0, 1.0);
  } else if (u_timeOfDay == 2) {
    colorA = vec3(1.0, 0.7, 0.4);
    colorB = vec3(0.15, 0.2, 0.3);
    cloudColor = vec3(1.0, 0.9, 0.8);
  } else {
    colorA = vec3(0.05, 0.1, 0.2);
    colorB = vec3(0.0, 0.0, 0.0);
    cloudColor = vec3(0.1, 0.1, 0.15);
  }
  vec3 skyColor = mix(colorB, colorA, skyMix);
  float cloudNoise = fbm(dir * 5.0);
  float cloudDensity;
  if (u_timeOfDay == 3) {
    cloudDensity = smoothstep(0.55, 0.7, cloudNoise) * 0.5;
  } else {
    cloudDensity = smoothstep(0.4, 0.7, cloudNoise);
  }
  vec3 finalColor = mix(skyColor, cloudColor, cloudDensity);
  if (u_timeOfDay != 3) {
    float sunDisc = smoothstep(0.995, 0.998, sunDot);
    if (sunDisc > 0.0) {
      vec3 sunColor = (u_timeOfDay == 2) ? vec3(1.0, 0.9, 0.7) : vec3(1.0, 1.0, 0.95);
      finalColor = mix(finalColor, sunColor, sunDisc);
    }
  }
  if (u_timeOfDay == 3) {
    float moonDisc = smoothstep(0.996, 0.998, moonDot);
    if (moonDisc > 0.0) {
      vec3 moonColor = vec3(0.9, 0.9, 1.0);
      finalColor = mix(finalColor, moonColor, moonDisc);
    }
  }
  if (u_timeOfDay == 3) {
    vec3 sd = normalize(dir);
    sd = floor(sd * 800.0) / 800.0;
    float starNoise = hash(sd * 500.0);
    float stars = step(0.9995, starNoise) * max(dir.y, 0.0);
    finalColor += vec3(stars * 0.9);
  }
  gl_FragColor = vec4(finalColor, 1.0);
  return;
 }

 // --- ##### MODIFIED GROUND MODE ##### ---

 // 1. Get base color (grid + snow)
 float gx = abs(fract(v_pos.x) - 0.5);
 float gz = abs(fract(v_pos.z) - 0.5);
 float line = step(0.48, max(gx, gz));
 vec3 gridColor = mix(vec3(0.1, 0.35, 0.1), vec3(0.0, 0.0, 0.0), line);
 //float snowMix = smoothstep(5.0, 7.5, v_pos.y);
 //vec3 snowColor = vec3(0.9, 0.9, 0.9);
 //vec3 baseColor = mix(gridColor, snowColor, snowMix);
 vec3 baseColor = gridColor;

 // 2. Calculate Lighting
 vec3 normal = normalize(v_nrm);
 float ambient = 0.2; // Base light so shadows aren't pure black

 // Calculate diffuse light (how much the sun hits this surface)
 // At night, use the moon (opposite sun) and make it dimmer
 vec3 lightDir = (u_timeOfDay == 3) ? normalize(-u_sunDir) : u_sunDir;
 float diffuse = max(dot(normal, lightDir), 0.0);
 
 // At night, reduce the diffuse and ambient light
 if (u_timeOfDay == 3) {
   diffuse *= 0.2; // Moon is much dimmer
   ambient = 0.2; // Night ambient is very low
 }
 
 // 3. Combine base color and lighting
 vec3 finalColor = baseColor * (ambient + diffuse);

 gl_FragColor = vec4(finalColor, 1.0);
}`;


/* ===== Build Program (unchanged) ===== */
function sh(t,s){
     let o = gl.createShader(t);
     gl.shaderSource(o,s);
     gl.compileShader(o);
     if(!gl.getShaderParameter(o,gl.COMPILE_STATUS))
               throw gl.getShaderInfoLog(o);
     return o;
}
let prog = gl.createProgram();
gl.attachShader(prog, sh(gl.VERTEX_SHADER, vsSrc));
gl.attachShader(prog, sh(gl.FRAGMENT_SHADER, fsSrc));
gl.linkProgram(prog);
let u_mode = gl.getUniformLocation(prog, "u_mode");
let u_timeOfDay = gl.getUniformLocation(prog, "u_timeOfDay");
let u_sunDir = gl.getUniformLocation(prog, "u_sunDir");
gl.useProgram(prog);
let a_pos = gl.getAttribLocation(prog, "a_pos");
let u_mvp = gl.getUniformLocation(prog, "u_mvp");
let a_nrm = gl.getAttribLocation(prog, "a_nrm");

/* ===== Helpers ===== */

// --- ADDED: JS Noise Functions (Ported from shader) ---
function fract(n) { return n - Math.floor(n); }
function dot(a, b) { return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]; }
function mix(a, b, t) { return a * (1.0 - t) + b * t; }

function hash_js(p) { // p is [x, y, z]
     let p_v = [
          fract(p[0] * 0.1031),
          fract(p[1] * 0.1030),
          fract(p[2] * 0.0973)
     ];
     let dot_val = dot(p_v, [p_v[1] + 33.33, p_v[2] + 33.33, p_v[0] + 33.33]);
     p_v[0] += dot_val;
     p_v[1] += dot_val;
     p_v[2] += dot_val;
     return fract((p_v[0] + p_v[1]) * p_v[2]);
}

function noise_js(p) { // p is [x, y, z]
     let i = [Math.floor(p[0]), Math.floor(p[1]), Math.floor(p[2])];
     let f = [fract(p[0]), fract(p[1]), fract(p[2])];
     let u = [
          f[0]*f[0]*(3.0-2.0*f[0]),
          f[1]*f[1]*(3.0-2.0*f[1]),
          f[2]*f[2]*(3.0-2.0*f[2])
     ];
     
     let a = hash_js([i[0] + 0.0, i[1] + 0.0, i[2] + 0.0]);
     let b = hash_js([i[0] + 1.0, i[1] + 0.0, i[2] + 0.0]);
     let c = hash_js([i[0] + 0.0, i[1] + 1.0, i[2] + 0.0]);
     let d = hash_js([i[0] + 1.0, i[1] + 1.0, i[2] + 0.0]);
     let e = hash_js([i[0] + 0.0, i[1] + 0.0, i[2] + 1.0]);
     let f_ = hash_js([i[0] + 1.0, i[1] + 0.0, i[2] + 1.0]);
     let g = hash_js([i[0] + 0.0, i[1] + 1.0, i[2] + 1.0]);
     let h = hash_js([i[0] + 1.0, i[1] + 1.0, i[2] + 1.0]);
     
     return mix(mix(mix(a, b, u[0]), mix(c, d, u[0]), u[1]),
                                   mix(mix(e, f_, u[0]), mix(g, h, u[0]), u[1]), u[2]);
}

function fbm_js(p) { // p is [x, y, z]
     let total = 0.0;
     let amplitude = 0.5;
     let frequency = 1.0;
     for(let i = 0; i < 4; i++) {
          let p_freq = [p[0] * frequency, p[1] * frequency, p[2] * frequency];
          total += amplitude * noise_js(p_freq);
          frequency *= 2.0;
          amplitude *= 0.5;
     }
     return total;
}
// --- END ADDED: JS Noise Functions ---


// --- ADDED: Ground Mesh Generation ---
function createGroundMesh(size, segments) {
 const vertices = [];
 const indices = [];
 const normals = []; // NEW: Array for normals
 const segmentSize = size / segments;
 const halfSize = size / 2;
 const noiseScale = 0.05;
 const heightScale = 15.0; //15.0
 const vertsPerRow = segments + 1;

 // Helper function to get height at a grid point
 const getHeight = (x, z) => {
  return fbm_js([x * noiseScale, 0.0, z * noiseScale]) * heightScale;
 };

 // First pass: Create all vertices
 for (let i = 0; i <= segments; i++) { // z-direction
  for (let j = 0; j <= segments; j++) { // x-direction
   let x = j * segmentSize - halfSize;
   let z = i * segmentSize - halfSize;
   let y = getHeight(x, z);
   vertices.push(x, y, z);
   normals.push(0, 1, 0); // Push a temporary "up" normal
  }
 }
 
 // Second pass: Create indices
 for (let i = 0; i < segments; i++) {
  for (let j = 0; j < segments; j++) {
   let a = (i * vertsPerRow) + j;
   let b = a + 1;
   let c = ((i + 1) * vertsPerRow) + j;
   let d = c + 1;
   indices.push(a, c, b);
   indices.push(b, c, d);
  }
 }

 // NEW: Third pass: Calculate normals
 // We zero out the temp normals first
 for (let i = 0; i < normals.length; i++) {
  normals[i] = 0.0;
 }

 // Go through each triangle
 for (let i = 0; i < indices.length; i += 3) {
  const i1 = indices[i + 0] * 3; // Index to vertex 1
  const i2 = indices[i + 1] * 3; // Index to vertex 2
  const i3 = indices[i + 2] * 3; // Index to vertex 3

  // Get vertices
  const v1 = [vertices[i1], vertices[i1+1], vertices[i1+2]];
  const v2 = [vertices[i2], vertices[i2+1], vertices[i2+2]];
  const v3 = [vertices[i3], vertices[i3+1], vertices[i3+2]];

  // Calculate triangle edges
  const edge1 = [v2[0] - v1[0], v2[1] - v1[1], v2[2] - v1[2]];
  const edge2 = [v3[0] - v1[0], v3[1] - v1[1], v3[2] - v1[2]];

  // Cross product to get the face normal
  const nx = edge1[1] * edge2[2] - edge1[2] * edge2[1];
  const ny = edge1[2] * edge2[0] - edge1[0] * edge2[2];
  const nz = edge1[0] * edge2[1] - edge1[1] * edge2[0];
  const len = Math.hypot(nx, ny, nz);
  const norm = [nx/len, ny/len, nz/len];

  // Add this face normal to all 3 vertices' normals
  normals[i1] += norm[0]; normals[i1+1] += norm[1]; normals[i1+2] += norm[2];
  normals[i2] += norm[0]; normals[i2+1] += norm[1]; normals[i2+2] += norm[2];
  normals[i3] += norm[0]; normals[i3+1] += norm[1]; normals[i3+2] += norm[2];
 }

 // NEW: Fourth pass: Normalize all vertex normals
 for (let i = 0; i < normals.length; i += 3) {
  const len = Math.hypot(normals[i], normals[i+1], normals[i+2]);
  if (len > 0) {
   normals[i] /= len;
   normals[i+1] /= len;
   normals[i+2] /= len;
  }
 }
 
 return {
  vertices: new Float32Array(vertices),
  indices: new Uint16Array(indices),
  normals: new Float32Array(normals) // NEW: Return normals
 };
}


function createSphere(radius, latitudeBands, longitudeBands) {
     // (unchanged)
          const vertices = [];
          const indices = [];
          for (let latNumber = 0; latNumber <= latitudeBands; latNumber++) {
                    const theta = latNumber * Math.PI / latitudeBands;
                    const sinTheta = Math.sin(theta);
                    const cosTheta = Math.cos(theta);
                    for (let longNumber = 0; longNumber <= longitudeBands; longNumber++) {
                              const phi = longNumber * 2 * Math.PI / longitudeBands;
                              const sinPhi = Math.sin(phi);
                              const cosPhi = Math.cos(phi);
                              const x = cosPhi * sinTheta;
                              const y = cosTheta;
                              const z = sinPhi * sinTheta;
                              vertices.push(radius * x);
                              vertices.push(radius * y);
                              vertices.push(radius * z);
                    }
          }
          for (let latNumber = 0; latNumber < latitudeBands; latNumber++) {
                    for (let longNumber = 0; longNumber < longitudeBands; longNumber++) {
                              const first = (latNumber * (longitudeBands + 1)) + longNumber;
                              const second = first + longitudeBands + 1;
                              indices.push(first);
                              indices.push(second);
                              indices.push(first + 1);
                              indices.push(second);
                              indices.push(second + 1);
                              indices.push(first + 1);
                    }
          }
          return { vertices: new Float32Array(vertices), indices: new Uint16Array(indices) };
}


function updateSunPosition(time) {
     // (unchanged)
          let x=0, y=0, z=0;
          if (time === 0) { x=0.0; y=0.8; z=-0.2; }
          else if (time === 1) { x=0.0; y=0.9; z=-0.1; }
          else if (time === 2) { x=-1.0; y=0.1; z=0.0; }
          else { x=0.0; y=-0.8; z=0.2; }
          const len = Math.hypot(x, y, z);
          if (len > 0) { sunDir[0] = x / len; sunDir[1] = y / len; sunDir[2] = z / len; }
}

/* ===== MODIFIED Ground ===== */
// Create a 200x200 unit wide mesh with 100x100 segments
const groundData = createGroundMesh(200, 100);
const groundVerts = groundData.vertices;
const groundIdx = groundData.indices;

let groundVBO = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, groundVBO);
gl.bufferData(gl.ARRAY_BUFFER, groundVerts, gl.STATIC_DRAW);

let groundIBO = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, groundIBO);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, groundIdx, gl.STATIC_DRAW);

// NEW: Ground Normal Buffer (NBO)
const groundNorms = groundData.normals;
let groundNBO = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, groundNBO);
gl.bufferData(gl.ARRAY_BUFFER, groundNorms, gl.STATIC_DRAW);


/* ===== Sphere Geometry (unchanged) ===== */
const sphereData = createSphere(250, 30, 30);
const sphereVerts = sphereData.vertices;
const sphereIdx = sphereData.indices;

let cubeVBO = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, cubeVBO);
gl.bufferData(gl.ARRAY_BUFFER, sphereVerts, gl.STATIC_DRAW);

let cubeIBO = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeIBO);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, sphereIdx, gl.STATIC_DRAW);


/* ===== Attribute Setup (unchanged) ===== */
gl.enableVertexAttribArray(a_pos);
gl.enableVertexAttribArray(a_nrm);

/* ===== Math Helpers (unchanged) ===== */
function m4(){return new Float32Array(16);}
function perspective(out,fovy,aspect,near,far){
     let f = 1 / Math.tan(fovy/2);
     out[0]=f/aspect; out[1]=0; out[2]=0; out[3]=0;
     out[4]=0; out[5]=f; out[6]=0; out[7]=0;
     out[8]=0; out[9]=0;
     out[10]=(far+near)/(near-far); out[11]=-1;
     out[12]=0; out[13]=0;
     out[14]=(2*far*near)/(near-far); out[15]=0;
}
function look(out, px, py, pz, yaw, pitch) {
     // (unchanged)
     const sy = Math.sin(yaw),         cy = Math.cos(yaw);
     const sp = Math.sin(pitch), cp = Math.cos(pitch);
     let fx = cp * sy;
     let fy = -sp;
     let fz = cp * -cy;
  let forward; // --- MODIFIED: declare forward up here ---
     if (!invertCamera) {
          fz = cp * cy;
          forward = [fx, fy, fz];
     } else {
          fz = cp * cy;
          forward = [fx, -fy, fz];
     }
     const upWorld=[0,1,0];
     let rx = forward[1]*upWorld[2] - forward[2]*upWorld[1];
     let ry = forward[2]*upWorld[0] - forward[0]*upWorld[2];
     let rz = forward[0]*upWorld[1] - forward[1]*upWorld[0];
     const rl = Math.hypot(rx,ry,rz);
     rx/=rl; ry/=rl; rz/=rl;
     const ux = ry*forward[2] - rz*forward[1];
     const uy = rz*forward[0] - rx*forward[2];
     const uz = rx*forward[1] - ry*forward[0];
     out[0]=rx; out[1]=ux; out[2]=-forward[0]; out[3]=0;
     out[4]=ry; out[5]=uy; out[6]=-forward[1]; out[7]=0;
     out[8]=rz; out[9]=uz; out[10]=-forward[2]; out[11]=0;
     out[12]=-(rx*px+ry*py+rz*pz);
     out[13]=-(ux*px+uy*py+uz*pz);
     out[14]= -(-forward[0]*px - forward[1]*py - forward[2]*pz);
     out[15]=1;
}

/* ---- Camera (unchanged) ---- */
let px=0, py=1.7, pz=5;
let yaw=0, pitch=0;
let keys={};
onkeydown=e=>keys[e.key.toLowerCase()]=true;
onkeyup=e=>keys[e.key.toLowerCase()]=false;

/* ---- Pointer lock mouse (unchanged) ---- */
let mouseLocked=false;
document.addEventListener("pointerlockchange",()=>{
     mouseLocked=(document.pointerLockElement===canvas);
});
document.addEventListener("mousemove", (e) => {
          if (!mouseLocked) return;
          yaw         += e.movementX * sensitivity;
          pitch -= e.movementY * sensitivity;
          const limit = 1.45;
          if (pitch > limit) pitch = limit;
          if (pitch < -limit) pitch = -limit;
});


/* ---- MODIFIED Main Loop ---- */
let last=0;
function loop(t){
     const dt=(t-last)/1000; last=t;

     const speed=5; //5
     const fwd=[Math.sin(yaw),0,Math.cos(yaw)];
     const right=[Math.cos(yaw),0,-Math.sin(yaw)];

     // --- Player X/Z Movement (unchanged) ---
     if(keys["w"]){px+=fwd[0]*speed*dt; pz+=fwd[2]*speed*dt;}
     if(keys["s"]){px-=fwd[0]*speed*dt; pz-=fwd[2]*speed*dt;}
     if(keys["a"]){px+=right[0]*speed*dt; pz+=right[2]*speed*dt;}
     if(keys["d"]){px-=right[0]*speed*dt; pz-=right[2]*speed*dt;}

     // --- ADDED: Terrain Following ---
     // Get the terrain height at the new (px, pz)
     // Must use the *same scale factors* as in createGroundMesh
     const noiseScale = 0.05; //0.05
     const heightScale = 15.0; //15.0
     let terrainHeight = fbm_js([px * noiseScale, 0.0, pz * noiseScale]) * heightScale;
     
     // Set player height to be 1.7 units above the terrain
     py = terrainHeight + 1.7;
     // --- END ADDED ---


     resize();
     gl.clearColor(0.5,0.75,1.0,1);
     gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);
     gl.enable(gl.DEPTH_TEST);

     let proj=m4(), view=m4(), mvp=m4();
     perspective(proj,Math.PI/3,canvas.width/canvas.height,0.1,500);
     look(view,px,py,pz,yaw,pitch);

     // --- Matrix multiplication (unchanged) ---
     for(let i=0;i<16;i++){
          let r=i&3,c=i>>2;
          mvp[i]=proj[r]*view[c*4] + proj[r+4]*view[c*4+1] +
     proj[r+8]*view[c*4+2] + proj[r+12]*view[c*4+3];
     }
     gl.uniformMatrix4fv(u_mvp,false,mvp);

     
     /* ==== DRAW GROUND (MODIFIED) ==== */
 gl.uniform1i(u_mode, 0); // draw as ground
 
 // Bind Position Buffer
 gl.bindBuffer(gl.ARRAY_BUFFER, groundVBO);
 gl.vertexAttribPointer(a_pos, 3, gl.FLOAT, false, 0, 0);
 
 // NEW: Bind Normal Buffer
 gl.bindBuffer(gl.ARRAY_BUFFER, groundNBO);
 gl.vertexAttribPointer(a_nrm, 3, gl.FLOAT, false, 0, 0);
 
 // Bind Index Buffer and Draw
 gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, groundIBO);
 gl.drawElements(gl.TRIANGLES, groundIdx.length, gl.UNSIGNED_SHORT, 0);

     /* ==== DRAW SPHERE (unchanged) ==== */
     gl.uniform1i(u_mode, 1);
     gl.uniform1i(u_timeOfDay, timeOfDay);
     gl.uniform3fv(u_sunDir, sunDir);
     gl.bindBuffer(gl.ARRAY_BUFFER, cubeVBO);
     gl.vertexAttribPointer(a_pos, 3, gl.FLOAT, false, 0, 0);
     gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeIBO);
     gl.drawElements(gl.TRIANGLES, sphereIdx.length, gl.UNSIGNED_SHORT, 0);


     requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

</script>
</body>
</html>
