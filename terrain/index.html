<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>WebGL FPS - Dynamic Controls</title>
<style>
    html,body{
        margin:0; height:100%; overflow:hidden; background:#000; font-family:sans-serif;
        /* Prevent default touch actions like scroll/zoom */
        touch-action: none;
        user-select: none;
        -webkit-user-select: none;
    }
    canvas{width:100vw;height:100vh;display:block;}

    /* Start menu overlay */
    #menu {
        position: absolute; inset: 0; background: rgba(0,0,0,0.75);
        display: flex; flex-direction: column; align-items: center; justify-content: center;
        color: white; z-index: 20;
    }
    #menu button { font-size: 20px; padding: 10px 20px; margin-top: 20px; cursor: pointer; }
    #menu label { font-size: 18px; margin-top: 10px; cursor: pointer; }

    /* --- TOUCH UI OVERLAY (Hidden by default) --- */
    #touch-ui {
        display: none; /* Hidden until touch event detected */
        position: absolute;
        inset: 0;
        pointer-events: none; /* Let touches pass through empty areas */
        z-index: 10;
    }

    /* Joystick Container */
    #joystick-zone {
        position: absolute;
        bottom: 50px;
        left: 50px;
        width: 120px;
        height: 120px;
        pointer-events: auto; /* Catch touches here */
    }

    /* Joystick Base */
    .joy-base {
        width: 100%; height: 100%;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.1);
        border: 2px solid rgba(255, 255, 255, 0.3);
        position: relative;
    }

    /* Joystick Knob */
    .joy-knob {
        width: 50px; height: 50px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.8);
        position: absolute;
        top: 50%; left: 50%;
        transform: translate(-50%, -50%);
        box-shadow: 0 0 10px rgba(0,0,0,0.5);
    }
    
    /* Touch Instructions */
    #touch-hint {
        position: absolute;
        bottom: 50px; right: 40px;
        color: rgba(255,255,255,0.4);
        font-weight: bold; text-align: right;
        pointer-events: none;
    }
</style>
</head>
<body>

<div id="menu">
    <h1>Start Game</h1>
    <label>
        <input type="checkbox" id="invertBox">
        Invert Camera
    </label>
    <label>
        <input type="range" id="sensitivitySlider" min="0.0001" max="0.01" step="0.001" value="0.002">
        sensitivity: <label id="sensitivityLabel">0.002</label>
    </label>
    <label for="timeSelect" style="margin-top: 10px; font-size: 18px;">Time of Day:</label>
    <select id="timeSelect" style="font-size: 16px; padding: 5px; margin-top: 5px; border-radius: 5px; background: #333; color: white; border: 1px solid #555;">
        <option value="0">Noon</option>
        <option value="1" selected>Midday</option>
        <option value="2">Sundown</option>
        <option value="3">Night</option>
    </select>
    <button id="startBtn">Start</button>
</div>

<div id="touch-ui">
    <div id="joystick-zone">
        <div class="joy-base">
            <div class="joy-knob" id="joy-knob"></div>
        </div>
    </div>
    <div id="touch-hint">Drag screen to look<br>Use stick to move</div>
</div>

<canvas id="c"></canvas>

<script>
// --- HTML Element Setup ---
const canvas=document.getElementById("c");
const menu=document.getElementById("menu");
const startBtn=document.getElementById("startBtn");
const invertBox=document.getElementById("invertBox");
const sensitivitySlider=document.getElementById("sensitivitySlider");
const sensitivityLabel=document.getElementById("sensitivityLabel");
const timeSelect = document.getElementById("timeSelect");

// Touch UI Elements
const touchUI = document.getElementById("touch-ui");
const joystickZone = document.getElementById("joystick-zone");
const joyKnob = document.getElementById("joy-knob");

let sensitivity = -0.002;
let invertCamera = false;
let timeOfDay = parseInt(timeSelect.value, 10);
let sunDir = new Float32Array(3);
updateSunPosition(timeOfDay);

// --- CONTROL MODE STATE ---
let inputMode = 'desktop'; // 'desktop' or 'touch'
let joystickVector = { x: 0, y: 0 };
let activeLookTouchId = null;
let touchLookLast = { x: null, y: null };

startBtn.onclick = () => {
     invertCamera = invertBox.checked;
     menu.style.display = "none";
     // If we are strictly on a mobile device, default to touch immediately
     if('ontouchstart' in window || navigator.maxTouchPoints > 0) {
        switchToDesktopMode()
     } else {
        canvas.requestPointerLock({unadjustedMovement:true});
     }
};
sensitivitySlider.onchange = () => {
     // Re-calc sensitivity based on slider and current mode
     updateSensitivity();
     sensitivityLabel.innerHTML = sensitivitySlider.value
};
invertBox.onchange = () => {
     invertCamera = invertBox.checked;
     updateSensitivity();
};
timeSelect.onchange = () => {
      timeOfDay = parseInt(timeSelect.value, 10);
      updateSunPosition(timeOfDay);
};

function updateSensitivity() {
    let base = parseFloat(sensitivitySlider.value);
    // Touch usually needs higher sensitivity than mouse
    if(inputMode === 'touch') base *= 2.0;
    
    sensitivity = invertCamera ? base : -base;
}

// --- DYNAMIC SWITCHING LOGIC ---

function switchToDesktopMode() {
    if(inputMode === 'desktop') return;
    inputMode = 'desktop';
    touchUI.style.display = 'none';
    joystickVector = {x:0, y:0}; // Stop moving
    updateSensitivity();
}

function switchToTouchMode() {
    if(inputMode === 'touch') return;
    inputMode = 'touch';
    touchUI.style.display = 'block';
    document.exitPointerLock?.(); // Unlock mouse if it was locked
    updateSensitivity();
}

// 1. Detect Keyboard -> Switch to Desktop
window.addEventListener('keydown', (e) => {
    switchToDesktopMode();
    keys[e.key.toLowerCase()] = true;
});
window.addEventListener('keyup', (e) => {
    keys[e.key.toLowerCase()] = false;
});

// 2. Detect Mouse Click -> Switch to Desktop & Lock
canvas.addEventListener('mousedown', () => {
    switchToDesktopMode();
    canvas.requestPointerLock({unadjustedMovement:true});
});

// 3. Detect Touch -> Switch to Touch
window.addEventListener('touchstart', (e) => {
    // If we touch the joystick or canvas, switch mode
    switchToTouchMode();
}, {passive: false});


/* ----------------------- WebGL Setup ----------------------- */
const gl=canvas.getContext("webgl");
if(!gl) alert("WebGL not supported");

function resize(){
     let dpr=window.devicePixelRatio||1;
     canvas.width=canvas.clientWidth*dpr;
     canvas.height=canvas.clientHeight*dpr;
     gl.viewport(0,0,canvas.width,canvas.height);
}
addEventListener("resize",resize);
resize();

/* ---- Shaders (unchanged) ---- */
const vsSrc=`
attribute vec3 a_pos;
attribute vec3 a_nrm;
uniform mat4 u_mvp;
varying vec3 v_pos;
varying vec3 v_nrm;
void main(){
     v_pos = a_pos;
     v_nrm = a_nrm;
     gl_Position = u_mvp * vec4(a_pos,1.0);
}`;

const fsSrc = `
precision highp float;
varying vec3 v_pos;
varying vec3 v_nrm;
uniform int u_mode;
uniform int u_timeOfDay;
uniform vec3 u_sunDir;

float hash(vec3 p) {
  p = fract(p * vec3(0.1031, 0.1030, 0.0973));
  p += dot(p, p.yzx + 33.33);
  return fract((p.x + p.y) * p.z);
}
float noise(vec3 p) {
  vec3 i = floor(p); vec3 f = fract(p);
  vec3 u = f * f * (3.0 - 2.0 * f);
  float a = hash(i + vec3(0.0, 0.0, 0.0));
  float b = hash(i + vec3(1.0, 0.0, 0.0));
  float c = hash(i + vec3(0.0, 1.0, 0.0));
  float d = hash(i + vec3(1.0, 1.0, 0.0));
  float e = hash(i + vec3(0.0, 0.0, 1.0));
  float f_ = hash(i + vec3(1.0, 0.0, 1.0));
  float g = hash(i + vec3(0.0, 1.0, 1.0));
  float h = hash(i + vec3(1.0, 1.0, 1.0));
  return mix(mix(mix(a, b, u.x), mix(c, d, u.x), u.y),
       mix(mix(e, f_, u.x), mix(g, h, u.x), u.y), u.z);
}
float fbm(vec3 p) {
  float total = 0.0; float amplitude = 0.5; float frequency = 1.0;
  for(int i = 0; i < 4; i++) {
    total += amplitude * noise(p * frequency);
    frequency *= 2.0; amplitude *= 0.5;
  }
  return total;
}
void main() {
 if (u_mode == 1) {
  vec3 dir = normalize(v_pos);
  vec3 moonDir = normalize(-u_sunDir);
  float sunDot = dot(dir, u_sunDir);
  float moonDot = dot(dir, moonDir);
  float skyMix;
  if (u_timeOfDay == 0) skyMix = smoothstep(-0.2, 0.7, sunDot);
  else if (u_timeOfDay == 2) skyMix = smoothstep(-0.1, 0.5, sunDot);
  else skyMix = max(dir.y, 0.0);
  vec3 colorA, colorB, cloudColor;
  if (u_timeOfDay == 0) { colorA=vec3(0.8,0.9,1.0); colorB=vec3(0.3,0.5,0.8); cloudColor=vec3(1.0); }
  else if (u_timeOfDay == 1) { colorA=vec3(0.6,0.8,1.0); colorB=vec3(0.3,0.5,0.8); cloudColor=vec3(1.0); }
  else if (u_timeOfDay == 2) { colorA=vec3(1.0,0.7,0.4); colorB=vec3(0.15,0.2,0.3); cloudColor=vec3(1.0,0.9,0.8); }
  else { colorA=vec3(0.05,0.1,0.2); colorB=vec3(0.0); cloudColor=vec3(0.1,0.1,0.15); }
  vec3 skyColor = mix(colorB, colorA, skyMix);
  float cloudNoise = fbm(dir * 5.0);
  float cloudDensity = (u_timeOfDay == 3) ? smoothstep(0.55, 0.7, cloudNoise)*0.5 : smoothstep(0.4, 0.7, cloudNoise);
  vec3 finalColor = mix(skyColor, cloudColor, cloudDensity);
  if (u_timeOfDay != 3) {
    float sunDisc = smoothstep(0.995, 0.998, sunDot);
    if (sunDisc > 0.0) {
      vec3 sunColor = (u_timeOfDay == 2) ? vec3(1.0, 0.9, 0.7) : vec3(1.0, 1.0, 0.95);
      finalColor = mix(finalColor, sunColor, sunDisc);
    }
  }
  if (u_timeOfDay == 3) {
    float moonDisc = smoothstep(0.996, 0.998, moonDot);
    if (moonDisc > 0.0) finalColor = mix(finalColor, vec3(0.9,0.9,1.0), moonDisc);
    vec3 sd = normalize(dir); sd = floor(sd * 800.0) / 800.0;
    float starNoise = hash(sd * 500.0);
    float stars = step(0.9995, starNoise) * max(dir.y, 0.0);
    finalColor += vec3(stars * 0.9);
  }
  gl_FragColor = vec4(finalColor, 1.0);
  return;
 }
 float gx = abs(fract(v_pos.x) - 0.5);
 float gz = abs(fract(v_pos.z) - 0.5);
 float line = step(0.48, max(gx, gz));
 vec3 gridColor = mix(vec3(0.1, 0.35, 0.1), vec3(0.0, 0.0, 0.0), line);
 vec3 baseColor = gridColor;
 vec3 normal = normalize(v_nrm);
 float ambient = 0.2;
 vec3 lightDir = (u_timeOfDay == 3) ? normalize(-u_sunDir) : u_sunDir;
 float diffuse = max(dot(normal, lightDir), 0.0);
 if (u_timeOfDay == 3) { diffuse *= 0.2; ambient = 0.2; }
 vec3 finalColor = baseColor * (ambient + diffuse);
 gl_FragColor = vec4(finalColor, 1.0);
}`;

/* ===== Build Program ===== */
function sh(t,s){
     let o = gl.createShader(t); gl.shaderSource(o,s); gl.compileShader(o);
     if(!gl.getShaderParameter(o,gl.COMPILE_STATUS)) throw gl.getShaderInfoLog(o);
     return o;
}
let prog = gl.createProgram();
gl.attachShader(prog, sh(gl.VERTEX_SHADER, vsSrc));
gl.attachShader(prog, sh(gl.FRAGMENT_SHADER, fsSrc));
gl.linkProgram(prog);
let u_mode = gl.getUniformLocation(prog, "u_mode");
let u_timeOfDay = gl.getUniformLocation(prog, "u_timeOfDay");
let u_sunDir = gl.getUniformLocation(prog, "u_sunDir");
gl.useProgram(prog);
let a_pos = gl.getAttribLocation(prog, "a_pos");
let u_mvp = gl.getUniformLocation(prog, "u_mvp");
let a_nrm = gl.getAttribLocation(prog, "a_nrm");

/* ===== Helpers ===== */
function fract(n) { return n - Math.floor(n); }
function dot(a, b) { return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]; }
function mix(a, b, t) { return a * (1.0 - t) + b * t; }
function hash_js(p) {
     let p_v = [ fract(p[0] * 0.1031), fract(p[1] * 0.1030), fract(p[2] * 0.0973) ];
     let dot_val = dot(p_v, [p_v[1] + 33.33, p_v[2] + 33.33, p_v[0] + 33.33]);
     p_v[0] += dot_val; p_v[1] += dot_val; p_v[2] += dot_val;
     return fract((p_v[0] + p_v[1]) * p_v[2]);
}
function noise_js(p) {
     let i = [Math.floor(p[0]), Math.floor(p[1]), Math.floor(p[2])];
     let f = [fract(p[0]), fract(p[1]), fract(p[2])];
     let u = [ f[0]*f[0]*(3.0-2.0*f[0]), f[1]*f[1]*(3.0-2.0*f[1]), f[2]*f[2]*(3.0-2.0*f[2]) ];
     let a = hash_js([i[0], i[1], i[2]]);
     let b = hash_js([i[0]+1.0, i[1], i[2]]);
     let c = hash_js([i[0], i[1]+1.0, i[2]]);
     let d = hash_js([i[0]+1.0, i[1]+1.0, i[2]]);
     let e = hash_js([i[0], i[1], i[2]+1.0]);
     let f_ = hash_js([i[0]+1.0, i[1], i[2]+1.0]);
     let g = hash_js([i[0], i[1]+1.0, i[2]+1.0]);
     let h = hash_js([i[0]+1.0, i[1]+1.0, i[2]+1.0]);
     return mix(mix(mix(a, b, u[0]), mix(c, d, u[0]), u[1]), mix(mix(e, f_, u[0]), mix(g, h, u[0]), u[1]), u[2]);
}
function fbm_js(p) {
     let total = 0.0; let amplitude = 0.5; let frequency = 1.0;
     for(let i = 0; i < 4; i++) {
          total += amplitude * noise_js([p[0]*frequency, p[1]*frequency, p[2]*frequency]);
          frequency *= 2.0; amplitude *= 0.5;
     }
     return total;
}

function createGroundMesh(size, segments) {
 const vertices=[], indices=[], normals=[];
 const segmentSize = size / segments;
 const halfSize = size / 2;
 const noiseScale = 0.05, heightScale = 15.0, vertsPerRow = segments + 1;
 const getHeight = (x, z) => fbm_js([x * noiseScale, 0.0, z * noiseScale]) * heightScale;

 for (let i = 0; i <= segments; i++) {
  for (let j = 0; j <= segments; j++) {
   let x = j * segmentSize - halfSize;
   let z = i * segmentSize - halfSize;
   vertices.push(x, getHeight(x, z), z);
   normals.push(0, 1, 0);
  }
 }
 for (let i = 0; i < segments; i++) {
  for (let j = 0; j < segments; j++) {
   let a = (i * vertsPerRow) + j;
   let b = a + 1;
   let c = ((i + 1) * vertsPerRow) + j;
   indices.push(a, c, b); indices.push(b, c, d=c+1);
  }
 }
 // Recalc normals
 for (let i = 0; i < normals.length; i++) normals[i] = 0.0;
 for (let i = 0; i < indices.length; i += 3) {
  const i1=indices[i]*3, i2=indices[i+1]*3, i3=indices[i+2]*3;
  const v1=[vertices[i1], vertices[i1+1], vertices[i1+2]];
  const v2=[vertices[i2], vertices[i2+1], vertices[i2+2]];
  const v3=[vertices[i3], vertices[i3+1], vertices[i3+2]];
  const e1=[v2[0]-v1[0], v2[1]-v1[1], v2[2]-v1[2]];
  const e2=[v3[0]-v1[0], v3[1]-v1[1], v3[2]-v1[2]];
  const nx=e1[1]*e2[2]-e1[2]*e2[1], ny=e1[2]*e2[0]-e1[0]*e2[2], nz=e1[0]*e2[1]-e1[1]*e2[0];
  const len=Math.hypot(nx, ny, nz);
  const norm=[nx/len, ny/len, nz/len];
  normals[i1]+=norm[0]; normals[i1+1]+=norm[1]; normals[i1+2]+=norm[2];
  normals[i2]+=norm[0]; normals[i2+1]+=norm[1]; normals[i2+2]+=norm[2];
  normals[i3]+=norm[0]; normals[i3+1]+=norm[1]; normals[i3+2]+=norm[2];
 }
 for (let i = 0; i < normals.length; i += 3) {
  const len = Math.hypot(normals[i], normals[i+1], normals[i+2]);
  if (len > 0) { normals[i]/=len; normals[i+1]/=len; normals[i+2]/=len; }
 }
 return { vertices: new Float32Array(vertices), indices: new Uint16Array(indices), normals: new Float32Array(normals) };
}

function createSphere(radius, latitudeBands, longitudeBands) {
          const vertices=[], indices=[];
          for (let latNumber = 0; latNumber <= latitudeBands; latNumber++) {
                    const theta = latNumber * Math.PI / latitudeBands;
                    const sinTheta = Math.sin(theta), cosTheta = Math.cos(theta);
                    for (let longNumber = 0; longNumber <= longitudeBands; longNumber++) {
                              const phi = longNumber * 2 * Math.PI / longitudeBands;
                              const sinPhi = Math.sin(phi), cosPhi = Math.cos(phi);
                              vertices.push(radius * cosPhi * sinTheta);
                              vertices.push(radius * cosTheta);
                              vertices.push(radius * sinPhi * sinTheta);
                    }
          }
          for (let latNumber = 0; latNumber < latitudeBands; latNumber++) {
                    for (let longNumber = 0; longNumber < longitudeBands; longNumber++) {
                              const first = (latNumber * (longitudeBands + 1)) + longNumber;
                              const second = first + longitudeBands + 1;
                              indices.push(first); indices.push(second); indices.push(first + 1);
                              indices.push(second); indices.push(second + 1); indices.push(first + 1);
                    }
          }
          return { vertices: new Float32Array(vertices), indices: new Uint16Array(indices) };
}

function updateSunPosition(time) {
          let x=0, y=0, z=0;
          if (time === 0) { x=0.0; y=0.8; z=-0.2; }
          else if (time === 1) { x=0.0; y=0.9; z=-0.1; }
          else if (time === 2) { x=-1.0; y=0.1; z=0.0; }
          else { x=0.0; y=-0.8; z=0.2; }
          const len = Math.hypot(x, y, z);
          if (len > 0) { sunDir[0] = x / len; sunDir[1] = y / len; sunDir[2] = z / len; }
}

const groundData = createGroundMesh(200, 100);
let groundVBO = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, groundVBO); gl.bufferData(gl.ARRAY_BUFFER, groundData.vertices, gl.STATIC_DRAW);
let groundIBO = gl.createBuffer(); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, groundIBO); gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, groundData.indices, gl.STATIC_DRAW);
let groundNBO = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, groundNBO); gl.bufferData(gl.ARRAY_BUFFER, groundData.normals, gl.STATIC_DRAW);

const sphereData = createSphere(250, 30, 30);
let cubeVBO = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, cubeVBO); gl.bufferData(gl.ARRAY_BUFFER, sphereData.vertices, gl.STATIC_DRAW);
let cubeIBO = gl.createBuffer(); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeIBO); gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, sphereData.indices, gl.STATIC_DRAW);

gl.enableVertexAttribArray(a_pos);
gl.enableVertexAttribArray(a_nrm);

function m4(){return new Float32Array(16);}
function perspective(out,fovy,aspect,near,far){
     let f = 1 / Math.tan(fovy/2);
     out[0]=f/aspect; out[1]=0; out[2]=0; out[3]=0; out[4]=0; out[5]=f; out[6]=0; out[7]=0;
     out[8]=0; out[9]=0; out[10]=(far+near)/(near-far); out[11]=-1;
     out[12]=0; out[13]=0; out[14]=(2*far*near)/(near-far); out[15]=0;
}
function look(out, px, py, pz, yaw, pitch) {
     const sy = Math.sin(yaw), cy = Math.cos(yaw);
     const sp = Math.sin(pitch), cp = Math.cos(pitch);
     let fx = cp * sy, fy = -sp, fz = cp * -cy;
     let forward = !invertCamera ? [fx, fy, cp*cy] : [fx, -fy, cp*cy];
     const upWorld=[0,1,0];
     let rx = forward[1]*upWorld[2] - forward[2]*upWorld[1];
     let ry = forward[2]*upWorld[0] - forward[0]*upWorld[2];
     let rz = forward[0]*upWorld[1] - forward[1]*upWorld[0];
     const rl = Math.hypot(rx,ry,rz);
     rx/=rl; ry/=rl; rz/=rl;
     const ux = ry*forward[2] - rz*forward[1];
     const uy = rz*forward[0] - rx*forward[2];
     const uz = rx*forward[1] - ry*forward[0];
     out[0]=rx; out[1]=ux; out[2]=-forward[0]; out[3]=0;
     out[4]=ry; out[5]=uy; out[6]=-forward[1]; out[7]=0;
     out[8]=rz; out[9]=uz; out[10]=-forward[2]; out[11]=0;
     out[12]=-(rx*px+ry*py+rz*pz);
     out[13]=-(ux*px+uy*py+uz*pz);
     out[14]= -(-forward[0]*px - forward[1]*py - forward[2]*pz);
     out[15]=1;
}

/* ---- Camera & Input ---- */
let px=0, py=1.7, pz=5;
let yaw=0, pitch=0;
let keys={};

let mouseLocked=false;
document.addEventListener("pointerlockchange",()=>{
     mouseLocked=(document.pointerLockElement===canvas);
});
document.addEventListener("mousemove", (e) => {
    // Only move if locked AND in desktop mode
    if (!mouseLocked || inputMode !== 'desktop') return;
    yaw   += e.movementX * sensitivity;
    pitch -= e.movementY * sensitivity;
    const limit = 1.45;
    if (pitch > limit) pitch = limit;
    if (pitch < -limit) pitch = -limit;
});

/* ================= TOUCH CONTROL LOGIC ================= */

// Joystick Logic
joystickZone.addEventListener('touchstart', (e) => {
    e.preventDefault();
    switchToTouchMode(); // Ensure we are in touch mode
    handleJoystickMove(e.changedTouches[0]);
}, {passive:false});

joystickZone.addEventListener('touchmove', (e) => {
    e.preventDefault();
    handleJoystickMove(e.changedTouches[0]);
}, {passive:false});

joystickZone.addEventListener('touchend', (e) => {
    e.preventDefault();
    joystickVector = {x:0, y:0};
    joyKnob.style.transform = `translate(-50%, -50%)`;
}, {passive:false});

function handleJoystickMove(touch) {
    const rect = joystickZone.getBoundingClientRect();
    const centerX = rect.left + rect.width / 2;
    const centerY = rect.top + rect.height / 2;
    let dx = (touch.clientX - centerX) * -1;
    let dy = (touch.clientY - centerY) * 1;
    const maxDist = rect.width / 2;
    const dist = Math.hypot(dx, dy);
    if (dist > maxDist) {
        dx = (dx / dist) * maxDist;
        dy = (dy / dist) * maxDist;
    }
    joyKnob.style.transform = `translate(calc(-50% + ${dx}px * -1), calc(-50% + ${dy}px))`;
    joystickVector.x = dx / maxDist;
    joystickVector.y = dy / maxDist;
}

// Look Logic
canvas.addEventListener('touchstart', (e) => {
    // Prevent switching to touch if hitting joystick,
    // but allow loop to catch other touches
    for (let i = 0; i < e.changedTouches.length; i++) {
        let t = e.changedTouches[i];
        if(t.target !== joystickZone && t.target !== joyKnob) {
            activeLookTouchId = t.identifier;
            touchLookLast.x = t.clientX;
            touchLookLast.y = t.clientY;
        }
    }
}, {passive: false});

canvas.addEventListener('touchmove', (e) => {
    if(inputMode !== 'touch') return;
    e.preventDefault();
    for (let i = 0; i < e.changedTouches.length; i++) {
        let t = e.changedTouches[i];
        if (t.identifier === activeLookTouchId) {
            const dx = t.clientX - touchLookLast.x;
            const dy = t.clientY - touchLookLast.y;
            yaw += dx * sensitivity;
            pitch -= dy * sensitivity;
            const limit = 1.45;
            if (pitch > limit) pitch = limit;
            if (pitch < -limit) pitch = -limit;
            touchLookLast.x = t.clientX;
            touchLookLast.y = t.clientY;
        }
    }
}, {passive: false});

canvas.addEventListener('touchend', (e) => {
    for (let i = 0; i < e.changedTouches.length; i++) {
        if (e.changedTouches[i].identifier === activeLookTouchId) {
            activeLookTouchId = null;
        }
    }
});


/* ---- Main Loop ---- */
let last=0;
function loop(t){
     const dt=(t-last)/1000; last=t;

     const speed=5;
     const fwd=[Math.sin(yaw),0,Math.cos(yaw)];
     const right=[Math.cos(yaw),0,-Math.sin(yaw)];

     // --- Logic: Combine Keyboard + Joystick ---
     let inputZ = 0;
     let inputX = 0;
     
     // Keyboard
     if(keys["w"]) inputZ += 1;
     if(keys["s"]) inputZ -= 1;
     if(keys["a"]) inputX += 1;
     if(keys["d"]) inputX -= 1;
     
     // Touch
     if(inputMode === 'touch') {
        inputZ -= joystickVector.y; // Up on stick is -Y screen, but +Z movement
        inputX += joystickVector.x;
     }

     // Apply Movement
     px += fwd[0] * speed * inputZ * dt;
     pz += fwd[2] * speed * inputZ * dt;
     px += right[0] * speed * inputX * dt;
     pz += right[2] * speed * inputX * dt;

     // Terrain Following
     const noiseScale = 0.05, heightScale = 15.0;
     let terrainHeight = fbm_js([px * noiseScale, 0.0, pz * noiseScale]) * heightScale;
     py = terrainHeight + 1.7;

     resize();
     gl.clearColor(0.5,0.75,1.0,1);
     gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);
     gl.enable(gl.DEPTH_TEST);

     let proj=m4(), view=m4(), mvp=m4();
     perspective(proj,Math.PI/3,canvas.width/canvas.height,0.1,500);
     look(view,px,py,pz,yaw,pitch);

     for(let i=0;i<16;i++){
          let r=i&3,c=i>>2;
          mvp[i]=proj[r]*view[c*4] + proj[r+4]*view[c*4+1] + proj[r+8]*view[c*4+2] + proj[r+12]*view[c*4+3];
     }
     gl.uniformMatrix4fv(u_mvp,false,mvp);

     // Draw Ground
     gl.uniform1i(u_mode, 0);
     gl.bindBuffer(gl.ARRAY_BUFFER, groundVBO); gl.vertexAttribPointer(a_pos, 3, gl.FLOAT, false, 0, 0);
     gl.bindBuffer(gl.ARRAY_BUFFER, groundNBO); gl.vertexAttribPointer(a_nrm, 3, gl.FLOAT, false, 0, 0);
     gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, groundIBO); gl.drawElements(gl.TRIANGLES, groundData.indices.length, gl.UNSIGNED_SHORT, 0);

     // Draw Sphere
     gl.uniform1i(u_mode, 1);
     gl.uniform1i(u_timeOfDay, timeOfDay);
     gl.uniform3fv(u_sunDir, sunDir);
     gl.bindBuffer(gl.ARRAY_BUFFER, cubeVBO); gl.vertexAttribPointer(a_pos, 3, gl.FLOAT, false, 0, 0);
     gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeIBO); gl.drawElements(gl.TRIANGLES, sphereData.indices.length, gl.UNSIGNED_SHORT, 0);

     requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>