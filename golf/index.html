<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>WebGL Golf</title>

  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: Arial, Helvetica, sans-serif;
      background: linear-gradient(135deg, #1e1e2f, #3a3a5a);
      background-repeat: no-repeat;
      background-size: cover;
      color: #fff;
      text-align: center;
      overflow-x: hidden;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    h1 {
      font-size: 2rem;
      margin: 20px 0;
      opacity: 0.9;
    }

    /* Canvas wrapper */
    .canvas-container {
      position: relative;
      margin: 0 auto;
      padding: 10px;
      background-color: #ffffff11;
      border-radius: 15px;
      backdrop-filter: blur(6px);
      width: 80vw;
      max-width: 800px;
      aspect-ratio: 1 / 0.6;
    }

    canvas {
      width: 100%;
      height: 100%;
      border-radius: 10px;
      display: block;
      background-color: #00000033;
    }

    /* DIRECTION ARROW */
    #aimArrow {
        position: absolute;
        top: 20px;
        left: 50%;
        /* Transform is now handled entirely by JS to prevent conflicts */
        transform-origin: center center;
        font-size: 3rem;
        color: #ffeb3b;
        text-shadow: 0 0 10px #ff9800;
        pointer-events: none;
        z-index: 5;
        transition: opacity 0.3s;
    }

    /* Win Screen Overlay */
    #winScreen {
      display: none;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.85);
      border-radius: 10px;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 20;
      animation: fadeIn 0.5s ease;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    #winTitle {
      font-size: 3rem;
      color: #4CAF50;
      margin-bottom: 5px;
      text-shadow: 0 0 10px #4CAF50;
    }

    #winSubtitle {
      font-size: 1.5rem;
      margin-bottom: 20px;
      color: #ddd;
    }

    .big-btn {
      padding: 15px 30px;
      font-size: 1.5rem;
      background: #4CAF50;
      color: white;
      border: none;
      border-radius: 50px;
      cursor: pointer;
      box-shadow: 0 4px 15px rgba(76, 175, 80, 0.4);
      transition: transform 0.2s;
    }
    .big-btn:hover {
      transform: scale(1.05);
      background: #45a049;
    }

    /* Controls panel */
    #controls {
      margin: 20px 0;
      padding: 15px;
      background-color: #ffffff22;
      border-radius: 12px;
      backdrop-filter: blur(6px);
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 15px;
      font-size: 1.1rem;
      z-index: 10;
    }

    body.is-fullscreen #controls {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background-color: #00000088;
        width: 80%;
    }

    body.is-fullscreen h1 { display: none; }

    body.is-fullscreen .canvas-container {
        position: fixed;
        top: 0; left: 0;
        width: 100vw; height: 100vh;
        max-width: none;
        padding: 0;
        border-radius: 0;
        z-index: 1;
    }
    
    body.is-fullscreen canvas { border-radius: 0; }
    body.is-fullscreen #winScreen { border-radius: 0; position: fixed; z-index: 30; }

    button.control-btn {
        background: #ff9900;
        border: none;
        padding: 5px 15px;
        color: white;
        border-radius: 5px;
        cursor: pointer;
        font-size: 1rem;
        font-weight: bold;
    }
    button.control-btn:hover { background: #ffb84d; }
    button.reset-btn { background: #e74c3c; }
    button.reset-btn:hover { background: #ff6b6b; }

    #controls span, #controls label {
      opacity: 0.9;
      display: flex;
      align-items: center;
      gap: 5px;
    }

    input[type="range"] {
      appearance: none;
      height: 6px;
      border-radius: 5px;
      background: #ffffff44;
    }
    input[type="range"]::-webkit-slider-thumb {
      appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #ffffffcc;
      cursor: pointer;
    }
    input[type="checkbox"] { transform: scale(1.2); }
  </style>
</head>

<body>

  <h1>WebGL Golf</h1>

  <div class="canvas-container">
    <canvas id="glcanvas"></canvas>
    
    <div id="aimArrow">âž¤</div>

    <div id="winScreen">
      <h2 id="winTitle">HOLE IN ONE!</h2>
      <p id="winSubtitle">Strokes: 1</p>
      <button class="big-btn" id="playAgainBtn">Play Next Hole</button>
    </div>
  </div>

  <div id="controls">
    <button class="control-btn" id="fsBtn">Go Fullscreen</button>
    <button class="control-btn reset-btn" id="resetBtn">New Level</button>
    
    <label>
      Vel:
      <input type="range" id="velocitySlider" min="-0.01" max="0.01" step="0.0005" value="0">
      <span id="velocityValue">0</span>
    </label>

    <label>
      <input type="checkbox" id="cameraZoom">
      Lock Zoom
    </label>

    <label>
      Zoom:
      <input type="range" id="zoomSlider" min="0.01" max="2" step="0.01" value="0.1">
      <span id="zoomValue">0.1</span>
    </label>
  </div>

  <script>
    const vsSource = `
  attribute vec2 aPosition;
  uniform vec2 uCameraOffset;
  uniform float uZoom;
  uniform float uAspect;
  varying float vY;
  uniform float sizex;

  void main() {
    vec2 position = (aPosition * vec2(sizex, 1) + uCameraOffset) * uZoom;
    vY = aPosition.y;
    gl_Position = vec4(position.x / uAspect, position.y, 0.0, 1.0);
  }
`;

const fsSource = `
  precision mediump float;
  uniform vec4 uColor;
  varying float vY;

  void main() {
    if (uColor.a == 0.0011) {
      float t = clamp((vY + 1.0) / 2.0, 0.0, 1.0);
      vec3 lowColor = vec3(0.0, 0.6, 0.0);
      vec3 highColor = vec3(0.6, 1.0, 0.6);
      vec3 baseColor = mix(lowColor, highColor, t);
      float noise = sin(vY * 50.0) * cos(vY * 40.0);
      float brightness = 0.9 + 0.1 * noise;
      gl_FragColor = vec4(baseColor * brightness, 1.0);
      return;
    }
    gl_FragColor = vec4(uColor.rgba);
    return;
  }
`;

    function initShader(gl, type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
      gl.enable(gl.BLEND);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        alert('Shader error: ' + gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    }

    function initProgram(gl, vsSource, fsSource) {
      const vertexShader = initShader(gl, gl.VERTEX_SHADER, vsSource);
      const fragmentShader = initShader(gl, gl.FRAGMENT_SHADER, fsSource);
      const program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        alert('Program error: ' + gl.getProgramInfoLog(program));
        return null;
      }
      return program;
    }

    function createCircleVertices(centerX, centerY, radius, segments) {
      const vertices = [centerX, centerY];
      for (let i = 0; i <= segments; i++) {
        const angle = i * 2 * Math.PI / segments;
        vertices.push(centerX + radius * Math.cos(angle), centerY + radius * Math.sin(angle));
      }
      return new Float32Array(vertices);
    }

    function createTerrainVertices(centerY, width, numPoints, heightVariation, hillCount) {
      const vertices = [];
      const step = width / (numPoints - 1);
      const controlPoints = [];
      const controlCount = hillCount + 3;

      for (let i = 0; i < controlCount; i++) {
        const x = -width / 2 + (i / (controlCount - 1)) * width;
        const y = centerY + (Math.random() - 0.5) * heightVariation * 2;
        controlPoints.push({ x, y });
      }

      function interpolate(p0, p1, p2, p3, t) {
        const t2 = t * t;
        const t3 = t2 * t;
        return 0.5 * (
          (2 * p1) +
          (-p0 + p2) * t +
          (2 * p0 - 5 * p1 + 4 * p2 - p3) * t2 +
          (-p0 + 3 * p1 - 3 * p2 + p3) * t3
        );
      }

      for (let i = 0; i < numPoints; i++) {
        const x = -width / 2 + i * step;
        const tGlobal = (x + width / 2) / width;
        const section = Math.floor(tGlobal * (controlPoints.length - 3));
        const localT = (tGlobal * (controlPoints.length - 3)) - section;

        const p0 = controlPoints[Math.max(0, section)];
        const p1 = controlPoints[section + 1];
        const p2 = controlPoints[section + 2];
        const p3 = controlPoints[Math.min(controlPoints.length - 1, section + 3)];

        const y = interpolate(p0.y, p1.y, p2.y, p3.y, localT);
        vertices.push(x, y);
      }
      return new Float32Array(vertices);
    }

    function calculateNormal(x1, y1, x2, y2) {
      const dx = x2 - x1;
      const dy = y2 - y1;
      const length = Math.sqrt(dx * dx + dy * dy);
      return { x: -dy / length, y: dx / length };
    }

    function reflectVelocity(velocity, normal) {
      const dot = velocity.x * normal.x + velocity.y * normal.y;
      return {
        x: velocity.x - 2 * dot * normal.x,
        y: velocity.y - 2 * dot * normal.y
      };
    }

    function generateSandPatchesWithClusters(terrainVertices, clusterCount, patchesPerCluster, radius, segments) {
      const patches = [];
      const terrainPoints = [];
      for (let i = 0; i < terrainVertices.length; i += 2) {
        terrainPoints.push({ x: terrainVertices[i], y: terrainVertices[i + 1] });
      }

      function getTerrainY(x) {
        for (let i = 0; i < terrainPoints.length - 1; i++) {
          const p1 = terrainPoints[i];
          const p2 = terrainPoints[i + 1];
          if (x >= p1.x && x <= p2.x) {
            const t = (x - p1.x) / (p2.x - p1.x);
            return p1.y + t * (p2.y - p1.y);
          }
        }
        return 0;
      }

      const clusterCenters = [];
      for (let i = 0; i < clusterCount; i++) {
        const idx = Math.floor(Math.random() * (terrainPoints.length - 2));
        clusterCenters.push({
          x: terrainPoints[idx].x,
          y: terrainPoints[idx].y
        });
      }

      for (const cluster of clusterCenters) {
        for (let i = 0; i < patchesPerCluster; i++) {
          const angle = Math.random() * 2 * Math.PI;
          const distance = Math.random() * 0.2;
          const cx = cluster.x + Math.cos(angle) * distance;
          const cy = getTerrainY(cx);

          const circleVerts = [cx, cy];
          for (let j = 0; j <= segments; j++) {
            const a = j * 2 * Math.PI / segments;
            const dx = Math.cos(a) * radius;
            const px = cx + dx;
            const py = getTerrainY(px);
            const dy = Math.sin(a) * radius;
            const finalY = Math.min(py, cy + dy);
            circleVerts.push(px, finalY);
          }
          patches.push(new Float32Array(circleVerts));
        }
      }
      return patches;
    }

    function isBallOnSandPatch(ballX, ballY, sandPatches) {
      for (const patch of sandPatches) {
        const cx = patch[0];
        const cy = patch[1];
        const dx = ballX - cx;
        const dy = ballY - cy;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < 0.25) {
          return true;
        }
      }
      return false;
    }

    function main() {
      const canvas = document.getElementById('glcanvas');
      const gl = canvas.getContext('webgl');
      if (!gl) {
        alert('WebGL not supported');
        return;
      }
      
      const program = initProgram(gl, vsSource, fsSource);
      gl.useProgram(program);

      const positionLoc = gl.getAttribLocation(program, 'aPosition');
      const colorLoc = gl.getUniformLocation(program, 'uColor');
      const cameraOffsetLoc = gl.getUniformLocation(program, 'uCameraOffset');
      const zoomLoc = gl.getUniformLocation(program, 'uZoom');
      const aspectLoc = gl.getUniformLocation(program, 'uAspect');
      const stretchie = gl.getUniformLocation(program, 'sizex');

      const buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.enableVertexAttribArray(positionLoc);
      gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);
      
      let stretch = 1;
      gl.uniform1f(stretchie, stretch);
      
      function resizeCanvas() {
        const displayWidth = canvas.clientWidth;
        const displayHeight = canvas.clientHeight;
        if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
          canvas.width = displayWidth;
          canvas.height = displayHeight;
          gl.viewport(0, 0, canvas.width, canvas.height);
        }
        const aspect = canvas.width / canvas.height;
        gl.uniform1f(aspectLoc, aspect);
        return aspect;
      }

      let currentAspect = resizeCanvas();
      window.addEventListener('resize', () => {
         currentAspect = resizeCanvas();
      });

      const fsBtn = document.getElementById('fsBtn');
      fsBtn.addEventListener('click', () => {
        if (!document.fullscreenElement) {
          document.body.requestFullscreen().catch(err => {
            alert(`Error: ${err.message}`);
          });
          document.body.classList.add('is-fullscreen');
          fsBtn.textContent = "Exit Fullscreen";
        } else {
          document.exitFullscreen();
          document.body.classList.remove('is-fullscreen');
          fsBtn.textContent = "Go Fullscreen";
        }
      });
      document.addEventListener('fullscreenchange', () => {
          if(!document.fullscreenElement) {
            document.body.classList.remove('is-fullscreen');
            fsBtn.textContent = "Go Fullscreen";
          }
      });

      // --- GAME VARIABLES ---
      let ballX, ballY, ballVelocityX, ballVelocityY;
      let terrainVertices, sandPatches;
      let holeX, holeY;
      let inhole = false;
      let strokes = 0;

      const gravity = -0.001;
      const bounceFactor = 0.6;
      const ballRadius = 0.05;
      const holeRadius = 0.03;
      const terrainHeight = 0;
      const terrainWidth = 100.0;
      const terrainPoints = 6000;
      const terrainHeightVariation = 0.3;
      const hillCount = 100;
      const terrainDepth = -100
      const power = 0.1;

      let cameraOffset = [0, 0];

      // --- UI REFERENCES ---
      const arrowEl = document.getElementById('aimArrow');
      const winTitle = document.getElementById('winTitle');
      const winSubtitle = document.getElementById('winSubtitle');

      function resetGame() {
        ballX = 0;
        ballY = 0.5;
        ballVelocityX = 0;
        ballVelocityY = 0;
        inhole = false;
        strokes = 0;

        terrainVertices = createTerrainVertices(
            terrainHeight,
            terrainWidth,
            terrainPoints,
            terrainHeightVariation,
            hillCount,
        );
        
        const holeIndex = Math.floor(Math.random() * (terrainVertices.length / 2 - 1));
        holeX = terrainVertices[holeIndex * 2];
        holeY = terrainVertices[holeIndex * 2 + 1];

        sandPatches = generateSandPatchesWithClusters(
            terrainVertices,
            10, 6, 0.25, 30
        );

        document.getElementById('winScreen').style.display = 'none';
        arrowEl.style.display = 'block';
      }

      resetGame();

      document.getElementById('resetBtn').addEventListener('click', resetGame);
      document.getElementById('playAgainBtn').addEventListener('click', resetGame);

      let addingVelocity = false;
      let currentSliderValue = 0;
      const velocitySlider = document.getElementById('velocitySlider');
      const velocityValue = document.getElementById('velocityValue');

      velocitySlider.addEventListener('input', () => {
        currentSliderValue = parseFloat(velocitySlider.value);
        velocityValue.textContent = velocitySlider.value;
      });
      velocitySlider.addEventListener('mousedown', () => addingVelocity = true);
      velocitySlider.addEventListener('touchstart', () => addingVelocity = true);
      window.addEventListener('mouseup', () => addingVelocity = false);
      window.addEventListener('touchend', () => addingVelocity = false);
      
      const zoomOutBox = document.getElementById('cameraZoom');
      let currentZoomSliderValue = 0.1;
      const zoomSlider = document.getElementById('zoomSlider');
      const zoomValue = document.getElementById('zoomValue');
      zoomSlider.addEventListener('input', () => {
        currentZoomSliderValue = parseFloat(zoomSlider.value);
        zoomValue.textContent = zoomSlider.value;
      });

      let isDragging = false;
      let dragEnd = null;

      function getMouseWorldCoords(e, canvas) {
        const rect = canvas.getBoundingClientRect();
        const ndcX = ((e.clientX - rect.left) / rect.width) * 2 - 1;
        const ndcY = -((e.clientY - rect.top) / rect.height) * 2 + 1;
        const aspectCorrectedX = ndcX * currentAspect;
        let currentZoom = zoomOutBox.checked ? currentZoomSliderValue : 1;
        const worldX = ((aspectCorrectedX / currentZoom) - cameraOffset[0]) / stretch;
        const worldY = (ndcY / currentZoom) - cameraOffset[1];
        return { x: worldX, y: worldY };
      }

      canvas.addEventListener('mousedown', e => {
        if(inhole) return;
        isDragging = true;
        dragEnd = getMouseWorldCoords(e, canvas);
      });

      canvas.addEventListener('mousemove', e => {
        if (isDragging) {
          dragEnd = getMouseWorldCoords(e, canvas);
        }
      });

      window.addEventListener('mouseup', e => {
        if(inhole) { isDragging = false; dragEnd = null; return; }

        const isStationary = Math.abs(ballVelocityX) < 0.001 && Math.abs(ballVelocityY) < 0.001;

        if (isDragging && dragEnd && (isStationary || isBallOnSandPatch(ballX, ballY, sandPatches))) {
            const dx = dragEnd.x - ballX;
            const dy = dragEnd.y - ballY;

            for (let i = 0; i < terrainVertices.length - 2; i += 2) {
                const x1 = terrainVertices[i];
                const y1 = terrainVertices[i + 1];
                const x2 = terrainVertices[i + 2];
                const y2 = terrainVertices[i + 3];

                if (ballX > x1 && ballX < x2) {
                    const t = (ballX - x1) / (x2 - x1);
                    const groundY = y1 + t * (y2 - y1);
                    const touchingGround = Math.abs(ballY - (groundY + ballRadius)) < 0.005;

                    if (touchingGround || isBallOnSandPatch(ballX, ballY, sandPatches)) {
                        
                        let zoomFactor = zoomOutBox.checked ? currentZoomSliderValue : 1.0;
                        let forceX = dx * power * zoomFactor;
                        let forceY = dy * power * zoomFactor;

                        const maxPower = 0.15;
                        const magnitude = Math.sqrt(forceX * forceX + forceY * forceY);
                        if (magnitude > maxPower) {
                            forceX = (forceX / magnitude) * maxPower;
                            forceY = (forceY / magnitude) * maxPower;
                        }

                        ballVelocityX += forceX;
                        ballVelocityY += forceY;
                        
                        strokes++;
                    }
                    break;
                }
            }
        }
        isDragging = false;
        dragEnd = null;
      });

      function draw() {
        currentAspect = resizeCanvas();
        gl.clearColor(0.6, 0.8, 1.0, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT);

        if (addingVelocity && !inhole) {
          ballVelocityX += currentSliderValue;
        }

        if (!inhole) {
            ballVelocityY += gravity;
            ballVelocityX *= 0.999;
            ballVelocityY *= 0.999;
            ballX += ballVelocityX;
            ballY += ballVelocityY;
        }
        
        let zoom = 1;
        if (zoomOutBox.checked) {
          zoom = currentZoomSliderValue
        }
        gl.uniform1f(zoomLoc, zoom);

        cameraOffset[0] = -ballX * stretch;
        cameraOffset[1] = -ballY;
        
        // --- FIXED ARROW LOGIC (Handled in JS) ---
        const distToHoleX = holeX - ballX;
        
        // Calculate Pulse and Rotation in JS to avoid CSS conflict
        const time = Date.now() * 0.005;
        const pulse = 1 + Math.sin(time) * 0.1; // Scale 0.9 to 1.1
        let rotation = 0;
        
        if (distToHoleX < 0) {
            rotation = 180; // Point Left
        }

        // Apply Transform string
        arrowEl.style.transform = `translateX(-50%) rotate(${rotation}deg) scale(${pulse})`;

        // Hide if close
        if (Math.abs(distToHoleX) < 2.0) {
            arrowEl.style.opacity = "0";
        } else {
            arrowEl.style.opacity = "1";
        }

        gl.uniform2f(cameraOffsetLoc, cameraOffset[0], cameraOffset[1]);

        const filledTerrain = [];
        for (let i = 0; i < terrainVertices.length; i += 2) {
            const x = terrainVertices[i];
            const y = terrainVertices[i + 1];
            filledTerrain.push(x, y);
            filledTerrain.push(x, terrainDepth);
        }
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(filledTerrain), gl.STATIC_DRAW);
        gl.uniform4f(colorLoc, 0.0, 0.8, 0.0, 0.0011);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, filledTerrain.length / 2);

        const ridgeVertices = [];
        for (let i = 0; i < terrainVertices.length; i += 2) {
            const x = terrainVertices[i];
            const y = terrainVertices[i + 1];
            ridgeVertices.push(x, y + 0.01);
            ridgeVertices.push(x, y - 0.01);
        }
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(ridgeVertices), gl.STATIC_DRAW);
        gl.uniform4f(colorLoc, 0.0, 0.75, 0.0, 1);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, ridgeVertices.length / 2);

        for (const patch of sandPatches) {
            gl.bufferData(gl.ARRAY_BUFFER, patch, gl.STATIC_DRAW);
            gl.uniform4f(colorLoc, 1.0, 0.9, 0.5, 1.0);
            gl.drawArrays(gl.TRIANGLE_FAN, 0, patch.length / 2);
        }

        const holeCircle = createCircleVertices(holeX, holeY + 0.001, holeRadius, 40);
        gl.bufferData(gl.ARRAY_BUFFER, holeCircle, gl.STATIC_DRAW);
        gl.uniform4f(colorLoc, 0.0, 0.0, 0.0, 1.0);
        gl.drawArrays(gl.TRIANGLE_FAN, 0, holeCircle.length / 2);

        const flagVertices = new Float32Array([
            holeX, holeY + holeRadius,
            holeX, holeY + holeRadius + 0.2
        ]);
        gl.bufferData(gl.ARRAY_BUFFER, flagVertices, gl.STATIC_DRAW);
        gl.uniform4f(colorLoc, 0.3, 0.2, 0.1, 1.0);
        gl.drawArrays(gl.LINES, 0, 2);

        const flagTriangle = new Float32Array([
            holeX, holeY + holeRadius + 0.2,
            holeX + 0.05, holeY + holeRadius + 0.17,
            holeX, holeY + holeRadius + 0.17
        ]);
        gl.bufferData(gl.ARRAY_BUFFER, flagTriangle, gl.STATIC_DRAW);
        gl.uniform4f(colorLoc, 1.0, 0.0, 0.0, 1.0);
        gl.drawArrays(gl.TRIANGLES, 0, 3);

        if (!inhole) {
            for (let i = 0; i < terrainVertices.length / 2 - 1; i++) {
                const x1 = terrainVertices[i * 2];
                const y1 = terrainVertices[i * 2 + 1];
                const x2 = terrainVertices[(i + 1) * 2];
                const y2 = terrainVertices[(i + 1) * 2 + 1];

                if (Math.abs(ballY - y1) < ballRadius && ballX > x1 && ballX < x2) {
                    const onSand = isBallOnSandPatch(ballX, ballY, sandPatches);
                    if (onSand) {
                        ballVelocityX *= 0.7;
                        ballVelocityY = 0;
                        ballY = y1 + ballRadius * 0.9;
                    } else {
                        const normal = calculateNormal(x1, y1, x2, y2);
                        const velocity = { x: ballVelocityX, y: ballVelocityY };
                        const reflected = reflectVelocity(velocity, normal);
                        ballVelocityX = reflected.x * 0.98;
                        ballVelocityY = reflected.y * bounceFactor;
                        ballY = y1 + ballRadius;
                    }
                    break;
                }
            }

            const dxHole = ballX - holeX;
            const dyHole = ballY - holeY;
            const distToHole = Math.sqrt(dxHole * dxHole + dyHole * dyHole);

            if (distToHole < holeRadius * 2.5) {
                inhole = true;
                ballX = holeX;
                ballY = holeY;
                ballVelocityX = 0;
                ballVelocityY = 0;
                
                if (strokes === 1) {
                    winTitle.innerText = "HOLE IN ONE!";
                } else {
                    winTitle.innerText = "HOLE COMPLETE!";
                }
                winSubtitle.innerText = `Strokes: ${strokes}`;
                
                document.getElementById('winScreen').style.display = 'flex';
                arrowEl.style.display = 'none';
            }
        }

        if (isDragging && dragEnd) {
            const lineVertices = new Float32Array([ballX, ballY, dragEnd.x, dragEnd.y]);
            gl.bufferData(gl.ARRAY_BUFFER, lineVertices, gl.STATIC_DRAW);
            gl.uniform4f(colorLoc, 0.2, 0.2, 1.0, 1.0);
            gl.drawArrays(gl.LINES, 0, 2);
        }

        const circle = createCircleVertices(ballX, ballY, ballRadius, 100);
        gl.bufferData(gl.ARRAY_BUFFER, circle, gl.STATIC_DRAW);
        gl.uniform4f(colorLoc, 1.0, 0.0, 0.0, 1.0);
        gl.drawArrays(gl.TRIANGLE_FAN, 0, circle.length / 2);

        requestAnimationFrame(draw);
      }

      draw();
    }

    main();
  </script>

</body>
</html>